!  Program qcdf90, write_read_conf, version 4.0.0

!  Copyright by Indranil Dasgupta, Andrea R. Levi, Vittorio Lubicz
!  and Claudio Rebbi  -  Boston University  -  January 1996
!  This program may be freely copied and used as long as this notice
!  is retained.
!
! su2 version  2006.08.28 by y.k.

!-----------------------------------------------------------
!             write_conf
!
! This subroutine writes out a configuration file in custom compressed
! format. See header data for more informations.
!
!-----------------------------------------------------------
   SUBROUTINE write_conf(beta,id,hp,saved_seed,filename)

   USE precisions
   USE constants
   USE global_module
   USE field_algebra
   USE generator_algebra
   USE random_numbers
   IMPLICIT NONE

   REAL(REAL8) beta,hp 
   INTEGER(LONG) saved_seed
   CHARACTER(LEN=16) id
   CHARACTER(LEN=64) filename
   !local:
   COMPLEX(REAL8) c
   INTEGER p,m,xyzt,i,j,pos
   INTEGER(LONG) one,two47,two48,l
   INTEGER(LONG) mask1,mask2,mask3,mask4,mask5,mask6,offset
   CHARACTER(LEN=8) lc,line(4)
   CHARACTER(LEN=8) date
   CHARACTER(LEN=10) time
   CHARACTER(LEN=78), DIMENSION(24) :: header_part1
   CHARACTER(LEN=78), DIMENSION(37) :: header_part2


   DATA header_part1/&
'#                                                                        ',&
'# This file contains a custom compressed gauge field configuration.      ',&
'#                                                                        ',&
'# At the end of the comment(#) lines the file contains the following     ',&
'# information:                                                           ',&
'#                                                                        ',&
'# one line with the NX, NY, NZ and NT extents of the hypecubical lattice,',&
'# the value of beta, the value of the hopping parameter k (k=0.0 denotes ',&
'# a quenched configuration), the date and time of the creation of the    ',&
'# file in Unix format and an optional identifier for the configuration.  ',&
'#                                                                        ',&
'# One line with the saved seed for the random number generator sequence. ',&
'#                                                                        ',&
'# 4*NX*NY*NZ*NT lines of 96 ASCII characters each, where each group      ',&
'# of eight subsequent characters codes a number in a format which will   ',&
'# be described in detail below.  Thus the 96 characters in a line        ',&
'# serve to code a sequence of 8  numbers which correspond to the         ',&
'# real and imaginary parts of the first two columns of a gauge field     ',&
'# matrix, stored in the following order along the line:                  ',&
'# Re(u(1,1)),Im(u(1,1)),Re(u(2,1)),Im(u(2,1)),                           ',&
'# Re(u(1,2)),Im(u(1,2)),Re(u(2,2)),Im(u(2,2))                            ',&
'# (the third column can be recovered from the unitarity and unimodularity',&
'# constraints).                                                          ',&
'#' /

   DATA header_part2/&
'# The 4*NX*NY*NZ*NT lines contain the full gauge field configuration     ',&
'# stored in the following order.  The sites of the lattice are divided   ',&
'# into sites of even and odd parity, with p=0,1 respectively, and, for   ',&
'# each parity, the sites are labeled by an index xyzt taking values from ',&
'# 0 to NX*NY*NZ*NT/2 - 1.  For each parity the sites are ordered by      ',&
'# increasing x first, then increasing y, then increasing z and finally   ',&
'# increasing t.  To be even more precise, the index xyzt(x,y,z,t,p)      ',&
'# associated to a site of Cartesian coordinates x,y,z,t and parity p     ',&
'# could be generated by the following program segment                    ',&
'# counter(0)=0; counter(1)=0; DO t=0,NT-1; DO z=0,NZ-1; DO y=0,NY-1;     ',&
'# DO x=0,NX-1; p=MOD(x+y+z+t,2); xyzt(x,y,z,t,p)=counter(p);             ',&  
'# counter(p)=counter(p)+1; ENDDO; ENDDO; ENDDO; ENDDO;                   ',&
'# Denoting further the direction of a link by m, with m=1,2,3 and 4      ',&
'# corresponding to the x,y,z and t directions respectively, and by       ',&
'# i and j (i,j=1,2) two SU(2) indices, all of the gauge field            ',&
'# variables can be conceptually represented by an array of components    ',&
'# u(i,j,xyzt,p,m).  Then, the order in which these variables are stored  ',&
'# stored in the subsequent lines corresponds to the following sequence   ',&
'# of loops:                                                              ',&
'# DO m=1,4 (outermost); DO p=0,1; DO xyzt=0,NX*NY*NZ*NT/2;               ',&
'# write the line with the first two columns of u(:,:,xyzt,p,m)           ',&
'# ENDDO; ENDDO; ENDDO;                                                   ',&
'#                                                                        ',&
'# Finally, the representation of the real and imaginary components       ',&
'# of the elements of u is as follows.  Let a be any of these numbers.    ',&
'# Because of the unitarity constraint  -1. <= a <= 1.                    ',&
'# We form the integer b=(a+1.)*2**47.  Clearly 0<=b<=2**48.              ',&
'# If b=2**48, then b is set to 2**48-1.  In this manner every number a   ',&
'# is put into correspondence with a 48bit unsigned integer b.            ',&
'# The groups of 8 subsequent characters express these integer numbers b  ',&
'# in base 64, (highest significant digit first, least significant last)  ',&
'# where the digits in base 64 are given by the ASCII collating sequence  ',&
'# starting from 0, namely                                                ',&
'# 0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmno       ',&
'# (for example, the group ;000000A would code the integer 11*64**7+17).  ',&
'#                                                                        ',&
'##' /



! tipical parameters:
!   beta =6.2_REAL8
!   hp=0.0
!   id='conf 0.0.0'

   CALL DATE_AND_TIME(date,time)

! generate the masks
   one=1
   two47=ISHFT(one,47)
   two48=ISHFT(one,48)
   mask1=ISHFT(one,24)-1
   mask2=ISHFT(mask1,24)
   mask3=ISHFT(one,12)-1
   mask3=IOR(mask3,ISHFT(mask3,32))
   mask4=ISHFT(mask3,12)
   mask5=ISHFT(one,6)-1
   mask5=IOR(mask5,ISHFT(mask5,16))   
   mask5=IOR(mask5,ISHFT(mask5,32))
   mask6=ISHFT(mask5,6)   
   offset=ICHAR('0')
   offset=IOR(offset,ISHFT(offset,32))
   offset=IOR(offset,ISHFT(offset,16))
   offset=IOR(offset,ISHFT(offset,8))


! write the header:
   OPEN(1,FILE=filename)
   DO i=1,24
      WRITE(1,'(A78)') header_part1(i)
   END DO
   DO i=1,37
      WRITE(1,'(A78)') header_part2(i)
   END DO


! write the parameters:
   WRITE(1,'(4I4,2X,F9.6,2X,F9.6,2X,A8,2X,A10,2X,A16)')  &
            NX,NY,NZ,NT,beta,hp,date,time,id
   WRITE(1,'(I15)') saved_seed

! write the configuration:
   DO m=1,4
     DO p=0,1
       DO xyzt=0,NXYZT2-1
         pos=0
         DO j=1,1
           DO i=1,2
             c=u%uc(p,m)%fc(i,j,xyzt)
             l=(REAL(c,REAL8)+1._REAL8)*two47     
             IF(l.EQ.two48) l=two48-1

             l=IAND(l,mask1)+ISHFT(IAND(l,mask2),8)
             l=IAND(l,mask3)+ISHFT(IAND(l,mask4),4)                   
             l=IAND(l,mask5)+ISHFT(IAND(l,mask6),2)+offset

             lc=TRANSFER(l,lc)
             pos=pos+1
             line(pos)=lc

             l=(AIMAG(c)+1._REAL8)*two47     
             IF(l.EQ.two48) l=two48-1

             l=IAND(l,mask1)+ISHFT(IAND(l,mask2),8)
             l=IAND(l,mask3)+ISHFT(IAND(l,mask4),4)                   
             l=IAND(l,mask5)+ISHFT(IAND(l,mask6),2)+offset            

             lc=TRANSFER(l,lc)
             pos=pos+1
             line(pos)=lc
           END DO
         END DO
         WRITE(1,'(4A8)')line
       END DO
     END DO
   END DO
        
   CLOSE(1)

   RETURN 
   END






!-----------------------------------------------------------
!             read_conf
!
! This subroutine read a configuration file in custom compressed format
!
!                             A.R.Levi, V.Lubicz and C.Rebbi
!                             Boston University, January 1996
!-----------------------------------------------------------
   SUBROUTINE read_conf(beta,id,hp,saved_seed,filename)

   USE precisions
   USE constants
   USE global_module
   USE field_algebra
   USE generator_algebra
   USE random_numbers
   IMPLICIT NONE

   REAL(REAL8) beta,hp 
   INTEGER(LONG) saved_seed
   CHARACTER(LEN=16) id
   CHARACTER(LEN=64) filename
   !local:
   REAL(REAL8) r1,r2
   INTEGER p,m,xyzt,i,j,pos
   INTEGER(LONG) one,two47,two48,l
   INTEGER(LONG) mask1,mask3,mask5,mask7,mask8,mask9,offset
   CHARACTER(LEN=8) lc,line(4)
   CHARACTER(LEN=78) header
   CHARACTER(LEN=8) date
   CHARACTER(LEN=10) time
   INTEGER new_nx,new_ny,new_nz,new_nt


! generate the masks
   one=1
   two47=ISHFT(one,47)
   two48=ISHFT(one,48)
   mask1=ISHFT(one,24)-1
   mask3=ISHFT(one,12)-1
   mask3=IOR(mask3,ISHFT(mask3,32))
   mask5=ISHFT(one,6)-1
   mask5=IOR(mask5,ISHFT(mask5,16))   
   mask5=IOR(mask5,ISHFT(mask5,32))
   mask7=ISHFT(mask1,32)   
   mask8=ISHFT(mask3,16)   
   mask9=ISHFT(mask5,8)   
   offset=ICHAR('0')
   offset=IOR(offset,ISHFT(offset,32))
   offset=IOR(offset,ISHFT(offset,16))
   offset=IOR(offset,ISHFT(offset,8))


! red the headers:
   OPEN(1,FILE=filename)
   DO i=1,100
      READ(1,'(A78)') header
      IF(header=='##') EXIT
   END DO

! read the parameters:
   READ(1,'(4I4,2X,F9.6,2X,F9.6,2X,A8,2X,A10,2X,A16)')&
            new_nx,new_ny,new_nz,new_nt,beta,hp,date,time,id
   READ(1,'(I15)') saved_seed

   IF(new_nx.NE.NX.OR.new_ny.NE.NY.OR.new_nz.NE.NZ.OR.new_nt.NE.NT)THEN
      PRINT *, '  LATTICE SIZES DO NOT CONFORM '
      STOP
   ENDIF

! read the configuration:
   DO m=1,4
     DO p=0,1
       DO xyzt=0,NXYZT2-1
         READ(1,'(4A8)')line
         pos=0
         DO j=1,1
           DO i=1,2
             pos=pos+1
             lc=line(pos)
             l=TRANSFER(lc,l)

             l=l-offset
             l=IAND(l,mask5)+ISHFT(IAND(l,mask9),-2)
             l=IAND(l,mask3)+ISHFT(IAND(l,mask8),-4)                   
             l=IAND(l,mask1)+ISHFT(IAND(l,mask7),-8)

             IF(l.EQ.two48-1) l=two48
             r1=REAL(l,REAL8)/REAL(two47,REAL8)-1._REAL8

             pos=pos+1
             lc=line(pos)
             l=TRANSFER(lc,l)

             l=l-offset
             l=IAND(l,mask5)+ISHFT(IAND(l,mask9),-2)
             l=IAND(l,mask3)+ISHFT(IAND(l,mask8),-4)                   
             l=IAND(l,mask1)+ISHFT(IAND(l,mask7),-8)

             IF(l.EQ.two48-1) l=two48
             r2=REAL(l,REAL8)/REAL(two47,REAL8)-1._REAL8
             u%uc(p,m)%fc(i,j,xyzt)=CMPLX(r1,r2)
           END DO
         END DO
       END DO
     END DO
   END DO
        
   CLOSE(1)

! reconstract the third row of U:
   DO m=1,4
     DO p=0,1
       DO xyzt=0,NXYZT2-1

         u%uc(p,m)%fc(1,2,xyzt)=-CONJG(u%uc(p,m)%fc(2,1,xyzt))
         u%uc(p,m)%fc(2,2,xyzt)=CONJG(u%uc(p,m)%fc(1,1,xyzt))

       END DO
       u%uc(p,m)%parity=p
       u%uc(p,m)%dir=m
     END DO
   END DO

   RETURN
   END
